I"/<h2 id="지뢰찾기자바스크립트-프로젝트-1회차"><strong>지뢰찾기(자바스크립트 프로젝트 1회차)</strong></h2>

<h3 id="20210514"><code class="language-plaintext highlighter-rouge">2021.05.14</code></h3>

<h4 id="소스코드-mine-sweeperhtml"><span style="color:navy">소스코드: <a href="https://github.com/WaterMinCho/JS/blob/main/mine-sweeper.html" target="\_blank">mine-sweeper.html</a></span></h4>

<hr />

<h3 id="플로우"><strong>플로우</strong></h3>

<ul>
  <li>
    <p>기본적으로 좌클릭을 했을 때랑 우클릭을 했을 때를 나눠서 처리해야 한다.</p>

    <ul>
      <li>
        <center><img src="https://user-images.githubusercontent.com/74204327/118597672-f2934c00-b7e7-11eb-8db1-3b9a8595c87e.png" width="80%" height="auto" alt="알고리즘" /></center>
      </li>
      <li>
        <center><img src="https://user-images.githubusercontent.com/74204327/118239686-11869b00-b4d5-11eb-96ef-66e8e38a1473.png" width="80%" height="auto" alt="알고리즘" /></center>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="배운-개념"><strong>배운 개념</strong></h3>

<p><span style="color:red">1. <a href="#상태에-따른-코드-정의">상태에 따른 코드 정의</a></span><br />
<span style="color:red">2. <a href="#순서">코드 작성 순서</a></span><br />
<span style="color:red">3. <a href="#optional-chaining">Optional Chaining</a></span><br />
<span style="color:red">4. <a href="#메서드">메서드</a> </span><br />
<span style="color:red">5. <a href="#클래스">클래스</a> </span><br />
 - <a href="#프로토타입이란">프로토타입</a><br />
<span style="color:red">5. <a href="#this">this</a> </span><br />
<span style="color:red">6. <a href="#클래스-상속">클래스 상속</a> </span><br />
<span style="color:red">7. <a href="#느낀-점">느낀 점</a> </span></p>

<hr />

<ul>
  <li>
    <h3 id="상태에-따른-코드-정의">상태에 따른 코드 정의</h3>

    <p>상태값에 따른 코드를 정의할 때 보통 숫자로 지정하는데 여러 번 시뮬레이션을 한 뒤에 최적의 숫자조합을 찾는 것이 현명하다.<br />
코드숫자는 0~8까지 열린 칸<br />
지뢰가 없을 때 <code class="language-plaintext highlighter-rouge">닫힌 칸(NORMAL)</code>은 -1, <code class="language-plaintext highlighter-rouge">물음표칸(QUESTION)</code>은 -2, <code class="language-plaintext highlighter-rouge">깃발 칸(FLAG)</code>은 -3.<br />
지뢰가 있을 때 <code class="language-plaintext highlighter-rouge">닫힌 칸은(MINE)</code> -4, <code class="language-plaintext highlighter-rouge">물음표칸(QUESTION_MINE)</code>은 -5, <code class="language-plaintext highlighter-rouge">깃발 칸(FLAG_MINE)</code>은 -6
<br /></p>
  </li>
</ul>

<hr />

<ul>
  <li>
    <h3 id="순서">순서</h3>

    <ol>
      <li>배열<code class="language-plaintext highlighter-rouge">candidate</code>에 빈 공간을 만들고 그 공간에 0부터 99까지 채워넣는다.</li>
      <li><code class="language-plaintext highlighter-rouge">chosen</code>배열에 <code class="language-plaintext highlighter-rouge">mine</code>갯수인 10개를 뺀 공간에 랜덤으로 채워넣는다.</li>
      <li>이차원 배열로 <code class="language-plaintext highlighter-rouge">rowData</code>배열에 <code class="language-plaintext highlighter-rouge">CODE.NORMAL(-1)</code>을 채워넣는다.</li>
      <li>랜덤하게 생성된 지뢰 칸 위치(shuffle[k])에 MINE(-6)을 data[][]에채워넣는다.</li>
      <li><code class="language-plaintext highlighter-rouge">onRightClick</code>함수 생성 후 <code class="language-plaintext highlighter-rouge">preventDefault</code>로 기본동작 제거. <code class="language-plaintext highlighter-rouge">target</code>으로 html코드 불러올 수 있음.</li>
      <li><code class="language-plaintext highlighter-rouge">$tbody.addEventListener("contextmenu", onRightClick);</code>에서 <code class="language-plaintext highlighter-rouge">contextmenu</code>는 우클릭이벤트인데 해당 이벤트 콜백을 <code class="language-plaintext highlighter-rouge">onRightClick</code>으로 적용.</li>
      <li><code class="language-plaintext highlighter-rouge">onLeftClick()</code>을 선언 후 닫힌 칸인지 지뢰칸(<code class="language-plaintext highlighter-rouge">지뢰칸이면 removeEventListener.</code>)인지 여부 판단 함.</li>
      <li><code class="language-plaintext highlighter-rouge">countMine()</code>도 정의해서 주변 지뢰갯수를 카운트한다.</li>
      <li>지뢰게임은 지뢰를 제외한 나머지 칸을 모두 열면 승리하는 게임이고 주변 지뢰개수가 0개인 칸을 클릭하면 자동으로 주변 칸을 모두 열어주는 기능도 넣어야 한다.</li>
      <li><code class="language-plaintext highlighter-rouge">openAround(), isNormal(), open()</code>을 정의해서 <code class="language-plaintext highlighter-rouge">open이 0</code>이면 <code class="language-plaintext highlighter-rouge">openAround</code>가 주변을 열어준다.</li>
      <li>승리하는 케이스일때 추가. 100칸 중에 10칸을 제외한 90칸을 모두 열면 승리하는 조건 추가하면 된다.</li>
      <li>줄, 칸, 지뢰 개수 조절하기–&gt;row,cell,mine변수에 input으로 submit할 수 있도록 세팅. submit하면 openCount초기화, tbody지우고 drawTable()실행, timer시작. –&gt; 해당하는 변수들을 let으로 수정.</li>
    </ol>
  </li>
</ul>

<hr />

<ul>
  <li>
    <h3 id="optional-chaining">Optional Chaining</h3>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">?.</code>
        <ul>
          <li>앞 평가 대상이 undefined나 null이면 평가를 멈추고 undefined를 반환한다. <code class="language-plaintext highlighter-rouge">.?</code>는 존재하지 않아도 괜찮은 대상에만 사용해야 한다.<br />
자바스크립트에선 배열에 음수번째 인덱스를 넣으면 <code class="language-plaintext highlighter-rouge">undefined</code>가 난다.<code class="language-plaintext highlighter-rouge">(undefined[-1])</code>
            <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
<span class="nx">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>            </div>
            <p>이런 식으로 커버할 수 있으며, 또는 접근자 <code class="language-plaintext highlighter-rouge">. 앞에 ?</code>를 붙이면 조건접근이 가능하다.</p>
          </li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">mines.includes(data[rowIndex - 1]?.[cellIndex - 1]) &amp;&amp; i++;</code>
        <ul>
          <li>data[][]가 존재하면 i++실행.</li>
        </ul>
      </li>
      <li>문법
        <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">obj</span><span class="p">?.</span><span class="nx">prop</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">?.[</span><span class="nx">expr</span><span class="p">];</span>
<span class="nx">arr</span><span class="p">?.[</span><span class="nx">index</span><span class="p">];</span>
<span class="nx">func</span><span class="p">?.(</span><span class="nx">args</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
      <li>.연산자는 <code class="language-plaintext highlighter-rouge">nullish참조값</code>일 때 에러를 뱉고 <code class="language-plaintext highlighter-rouge">?.</code>연산자는 에러 대신 <code class="language-plaintext highlighter-rouge">undefined</code>를 리턴하는 차이가 있다.</li>
      <li>
        <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">aProp</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">first</span><span class="p">?.</span><span class="nx">second</span><span class="p">;</span>
</code></pre></div>        </div>
        <p><code class="language-plaintext highlighter-rouge">obj.first.second</code>에 접근하기 전에 <code class="language-plaintext highlighter-rouge">obj.first가 nullish가 아니라는 것을 암묵적으로 확인했다는 뜻</code>이다. 만약 <code class="language-plaintext highlighter-rouge">obj.first가 nullish라면</code> 그 표현식은 자동으로 잘리고 <code class="language-plaintext highlighter-rouge">undefined가 반환</code>된다. 추가로 아래와 같이 풀어낼 수 있다. (참고:MDN)</p>
        <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">aProp</span> <span class="o">=</span>
  <span class="nx">obj</span><span class="p">.</span><span class="nx">first</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">first</span> <span class="o">===</span> <span class="kc">undefined</span>
    <span class="p">?</span> <span class="kc">undefined</span>
    <span class="p">:</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">first</span><span class="p">.</span><span class="nx">second</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<hr />

<ul>
  <li>
    <h2 id="nullish-coalescing-operatornull-병합-연산자">nullish coalescing operator(null 병합 연산자)</h2>

    <p><code class="language-plaintext highlighter-rouge">??, ||, &amp;&amp;</code>를 추가로 설명하면 기존에 and, or처럼 판단을 해왔지만 엄밀히 논리적으로 따지면 아래와 같다.</p>

    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>target.textContent = A</td>
              <td> </td>
              <td>B; <br /><code class="language-plaintext highlighter-rouge">A가 존재하지 않으면(false면) B.</code> <code class="language-plaintext highlighter-rouge">존재하면(true면) A.</code></td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>target.textContent = A ?? B; <br /><code class="language-plaintext highlighter-rouge">A가 Null 또는 Undefined면 B.</code> <code class="language-plaintext highlighter-rouge">그 외엔 A.</code></li>
      <li>mines.includes(A&amp;&amp;B);<br /><code class="language-plaintext highlighter-rouge">A가 존재하면(true면) B.</code> <code class="language-plaintext highlighter-rouge">존재하지 않으면(false면) A.</code></li>
    </ul>
  </li>
  <li>
    <h3 id="maximum-call-stack-size-exceeded-오류">Maximum call stack size exceeded 오류</h3>
    <ul>
      <li>재귀할 때 자주 나오는 오류 중 하나.</li>
      <li>최대 호출 스택 사이즈를 초과했다는 의미. 호출 스택의 관점에서 알아보자.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">OnLeftClick()</code>위에 <code class="language-plaintext highlighter-rouge">openAround()</code>가 여러 개가 얹어지면서 호출만하고 끝이 나지 않는 상황이 발생하여 <code class="language-plaintext highlighter-rouge">호출 스택</code>의 사이즈를 넘어가는 상황이 벌어진다.</li>
          <li>그럴 땐 비동기 코드로 감싸주고 <code class="language-plaintext highlighter-rouge">백그라운드</code>와 <code class="language-plaintext highlighter-rouge">태스크 큐</code>에 할당하면 된다.(<code class="language-plaintext highlighter-rouge">setTimeout()</code>)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
:ET